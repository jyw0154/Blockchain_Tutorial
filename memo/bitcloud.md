# 비트클라우드 백서

비트코인과 이더리움 백서 합본 한글판인 http://s.kwma.kr/pdf/BitCloud/bitcloudwpkor_p43.pdf를 읽고 요약 정리

---
## 비트코인: 개인간 전자화폐 시스템 (사토시 나카모토)

## 0. 초록

* 순 개인과 개인간의 전자화폐는 한 집단에서 다른 곳으로 금융기관을 거치지 않고 직접 온라인 지불을 가능하게 할 것
* <b>디지털 서명 기술이 일부 해결해주지만, 믿을 수 있는 제 3자가 이중지불을 방지해야 한다면 그 주요한 장점은 사라짐
* </b> 이 논문에서는 <b>P2P 네트워크를 이용한 이중지불 문제의 해결 방법</b>을 제안
* <b>암호화 기반 작업증명 과정</b>의 연쇄 상에서 네트워크 시간 및 거래를 암호화하여 기록을 생성하게 되면 작업증명 과정을 되풀이하지 않는 한 바꿀 수 없게 됨
* <b>가장 긴 체인은 각 사건 순서를 입증</b>해주기도 하며, 가장 많은 컴퓨팅 파워가 입증했다는 뜻
* 노드들에 의해 제어되는 컴퓨터 전력의 <b>과반수가 협력하여 네트워크를 공격하지 않는 한, 그들은 가장 긴 체인을 생성하며 네트워크 공격자를 능가하게 될 것</b>
* 이러한 네트워크는 <b>최소한의 구조를 필요</b>로 함
* 각 노드들은 자발적으로 그 네트워크를 떠나거나 다시 합류할 수 있고, 어떤 일이 벌어졌는지에 대한 입증으로 가장 긴 작업증명 체인을 받아들이는 노드들의 메시지가 최대한 공유

#### 디지털 서명 기술

1. 네트워크 송신자의 신원을 증명하는 방법
2. 송신자가 자신의 비밀키로 암호화한 메시지(Digital signature)를 수신자에게 보냄 
3. 수신자는 송신자의 공용 키로 이를 해독하여, 송신자의 신원 파악


#### 이중지불

1. 동일한 화폐를 중복하여 두 번이상 지출하는 것을 의미
2. 현실에서는 은행과 같은 제 3자가 이와 같은 이중 지불을 방지


#### 작업증명(Proof-of-Work, PoW)

* 목표값 이하의 해시를 찾는 과정을 무수히 반복함으로써 해당 <b>작업에 참여했음을 증명</b>하는 방식
* 작업증명 시스템: 서비스 요청자로부터 일부 작업을 요구함으로써(일반적으로 컴퓨터에 의한 처리시간을 의미) 서비스 거부(DoS) 공격과 기타 서비스 악용(예: 네트워크 상의 스팸)을 단념하게 만들기 위한 경제적인 수단

---
## 1. 서론

* 인터넷에서의 상거래는 거의 금융기관을 <b>제 3자 신용기관</b>으로 하는 전자지불 방식에 전적으로 의존하게 됨
* 대부분의 거래에 시스템은 충분히 작동하고 있지만, 여전히 <b>신용기반 모델이라는 내재적인 약점</b>을 가짐
* 비용과 지불의 불확실성은 사람이 직접 물리적으로 화폐를 지불하여 피할 수 있으나, <b>신용기관 없이 통신상으로 지불하는 방법은 존재하지 않음</b>
* 이러한 문제는 신용보다 암호화 기술에 기반한 전자지불 시스템을 이용하여 자발적인 두 거래자가 제 3자인 신용기관 없이도 직접적인 거래를 가능하게 만듦
* <b>전산적으로 번복이 불가능한</b> 송금은 판매자를 <b>가짜 지불로부터 보호</b>(이중지불 방지)할 수 있으며, 구매자는 일반 <b>에스크로 방식</b>을 통해 보호받음
* 이 논문에서는,
  1. 거래들의 시간 순서를 전산적으로 입증하게 만들도록 하는 <b>P2P 분산 네트워크 기반 타임스탬프 서버</b>를 이용하여 이중지불 문제를 방지하는 해법을 제안
  2. 악의적으로 협력하는 <b>노드</b> 그룹보다 정직한 노드들이 더 많은 컴퓨팅 파워를 총체적으로 제어하는 한 안전함


#### 신용기반 모델 약점
* 완전히 취소 가능한 거래는 사실상 불가능한데, <b>금융기관은 거래 상의 분쟁을 중재해야 하는 일</b>을 피할 수 없음
* 이러한 중재 비용은 <b>거래 수수료</b>를 올려 실질적인 최소 거래금액을 설정하여 <b>소액거래의 가능성을 제한</b>하고, 회수 불가능한 서비스는 <b>번복 불가능한 지불을 하게 만들어 더 많은 비용을 발생</b>
* 즉, <b>지불 번복을 위해 더 많은 신용을 요구</b>하여 번복하지 못하게 만듦
* 상업자들은 불필요한 더 많은 정보를 요구하여 고객을 귀찮게 만들고 경계


#### 에스크로 방식
* 상거래 시에, 판매자와 구매자의 사이에 신뢰할 수 있는 중립적인 제 3자가 중개하여 금전 또는 물품을 거래를 하도록 하는 것, 또는 그러한 서비스 방식
* 구체적으로는 판매자·구매자·제 3자의 사이에서 다음과 같은 절차로 진행
1. 구매자는 제삼자에게 대금을 맡긴다.
2. 판매자는 제삼자에게의 입금을 확인하고 구매자에게 상품을 발송한다.
3. 구매자는 송부된 상품을 확인하고 제삼자에게 상품이 도착했음을 알린다. 당초의 거래 내용과 다른 경우는, 상품을 반송하거나 거래를 파기할 수 있다.
4. 제삼자는 판매자에게 대금을 송금한다.
5. 판매자는 대금을 수령한다(거래의 종료).
* (m.t.) 에스크로 방식을 도입하는 것으로 보아, 제 3자의 존재를 남기는 것은 불가피 함으로 보임.


#### 타임스탬프
* 특정한 시각을 나타내는 문자열로서, 둘 이상의 시각을 비교하거나 기간을 계산할 때 편리하게 사용하기 위해 고안되었으며, 일관성 있는 형식으로 표현
* 파일시스템에서 타임스탬프는 저장된 파일이 생성되거나 변경된 시각을 뜻하기도 함


#### 비트코인 노드
* 비트코인 네트워크에 연결된 모든 컴퓨터를 노드라고 정의
* 노드들은 지갑, 블록체인 복사본, 검증엔진, 채굴, P2P 네트워크 전송 등의 기능을 갖고 있음
* 종류
1. Full Node: 비트코인 거래 정보(블록체인) 전부를 저장하고 비트코인 사용자들의 지갑을 관리하며 비트코인 네트워크상으로 직접 거래를 만들어 낼 수 있음
2. Lightweight Client: 사용자의 지갑을 저장하긴 하지만 비트코인 거래나 네트워크에 접근하기 위해서는 제 3자가 소유한 서버에 의존하며, 일반적으로 블록체인의 헤더정보만 저장
3 Web Client: 웹 브라우저를 통해 접속하며 제 3자가 소유한 서버상에서 사용자의 지갑을 저장(ex. 거래소)
4 모바일 비트코인: 스마트폰에서도 Full node, Lightweight/Web Client 사용 가능

* Full Node에 대해 조금 더 살펴보면,
1. 지갑, 블록체인 복사본, 검증엔진, 채굴, P2P 네트워크 전송등의 기능을 갖고 있는 노드
2. Full Node는 블록에 포함된 트랜잭션들과 블록 전체의 정합성(무모순성)을 검증
3. 검증을 통과한 블럭만 정당한 블록으로 인정하고, 로컬 데이터베이스를 업데이트하고 다른 노드로 전파
4. 블록체인 동기화 과정에 긴 시간과 많은 용량이 필요


---
## 2. 거래
* 이 논문에서는 <b>전자 화폐를 디지털 서명의 연속으로 정의</b>
* 각 암호키 소유자들은 그 전까지의 거래 내역에 다음 소유자의 공개키를 덧붙인 뒤에 자신의 비밀키로 암호화하는 디지털 서명을 하고 넘김
* 돈을 받은 사람은 서명 소유자들의 체인과 서명들을 검증할 수 있음


![Transaction](./image/transaction01.png)


* 돈을 받는 사람은 소유자들 중 한 명이 이중지불을 하지 않았는지 검증할 수가 없는 상황에서 문제가 발생
* 공통적인 해법은 각 거래가 이중지불이 되었는지 신용해주는 중앙기관을 도입하는 것
* 각 거래 후에, 그 화폐는 다시 새로운 화폐로 찍어내기 위해 중앙기관으로 회수되어야 하고, 이중지불이 아닌 것을 믿을 수 있도록 중앙기관에서만 직접 화폐를 발행하여 쓰도록 함
* 이러한 방법의 문제는 화폐 시스템 전체가 바로 은행 같은 중앙기관에 모든 거래 내역이 거쳐가도록 하는 방법에 의존하도록 된다는 것

* 결국 돈을 받는 사람이 이전 소유자가 그 전에도 어떤 거래에도 서명을 하지 않았는지를 확인할 방법이 필요 (m.t. 즉, 이중지불 확인할 방법 필요)
* 가장 먼저 일어난 거래 내역을 찾기만 해도 그 이후에 이중지불을 시도했는지 확인할 필요가 없음
* 거래 내역이 하나라도 비어있는지 확인하는 유일한 방법은 모든 거래 내역을 살펴 보는 것
* 바로 찍어낸 화폐를 기반으로 한 모델에서는 모든 거래를 확인하고 어느 것이 먼저 이뤄졌는지를 결정하면 됨
* 신용기관을 통하지 않고도 이런 방법을 가능하게 하기 위해서는, 모든 거래가 공개적으로 알려져야 하고[1], 참여자들이 시간 순서에 따라 단일 거래내역으로 수용하는 시스템이 필요
* 돈을 받는 사람은 매 거래 시마다, 과반수 이상의 노드들이 최초의 거래라고 인정해주는 시간 증명이 필요


---
## 2. 타임스탬프 서버
* 시간 내역이 기록된 항목들의 블록 해시를 취합하고, 신문이나 유즈넷 포스트처럼 그 해시를 널리 발행하는 역할[2~5]
* 타임스탬프 내역은 해시에 포함될 수 있도록 그 시간에 데이터가 명백히 존재했다는 것을 입증
* 각 타임스탬프 내역은 이전 타임스탬프로부터 받은 해시 내역을 포함시킴으로써 보강하는 체인을 형성

![Timestamp](./image/timestamp_server.png)


#### 중앙집권적 타임스탬프

인터넷 서비스는 불특정 다수의 사람들에게 서비스하는데 있어서 어느 한 곳에 중심을 두고 그 중심정의 시간을 기준으로 서비스 무결성을 유지하고 있다. 보통, <b>하나의 타임서버에 접근하여 시간 동기화를 하는 방식으로 모든 서버가 동일한 시간축</b>을 갖도록 사용하고 있다. 이 경우 타임서버가 해킹당한다면 시간축이 틀어질 수 있는 단점이 존재한다. 이 논문에서는 중앙집권적 구조가 아닌 P2P 형태의 구조를 생각한다.


![Sentralserver](./image/sentral_time_server.png)


#### 비중앙집권적 타임스탬프

P2P 시스템에서 중심부 시간에 의존하지 않은 상태로 타임스탬프를 필요로 하는 데이터를 처리하기 위해 새로운 타임스탬프 방법이 필요해졌다. 다시 말해, 타임스탬프가 필요한 서비스를 P2P로 실현하기 위해 중심부 시간에 동기하는 방법으로는 한계가 존재하여 블록체인 타임스탬프 개념이 나왔다. 블록체인이 획기적으로 보이는 이유는 시간을 되돌릴 수 없다는 것과 1개의 시간축을 모두가 공유하고, 그 시간축에서 전화 관계를 정의할 수 있는 물리적인 시간 특징을 암호학에 기초한 데이터 구조를 사용하여 다시 구현한 것이다.


![P2Pserver](./image/p2p_time_server.png)


#### 해시체인 타임스탬프

물리적 시간의 동기화가 확인하기 어려운 분산시스템에서 모든 참가자가 하나의 시간축을 공유하려면 어떤 시간이 일어난 절대적인 시간을 엄격하게 요구하는 것이 아니라, 전후 관계가 존재하는 2개의 사건에 대해 그 순서를 특정할 수 있는 상대적 시간으로 시간축을 정의하는 방법이 있다. 즉, 사건 1과 사건 2가 발생했을 때, 사건1과 사건 2가 일어난 정확한 시간은 몰라도 '사건 1이 사건 2 다음에 발생했다'라는 상대적인 전후 관계만을 취급한다는 것이다. 이 개념은 <b>분산시스템의 논리적 타임스탬프</b>라고 말한다.

블록체인은 암호화 해시함수를 사용하여 데이터가 존재하기 전에 다른 데이터가 존재했다는 전후 관계를 논리적으로 부정할 수 없는 형태로 정의하고 있다.

![Hashserver](./image/hash_timeserver.png)

위 그림에서 A데이터에 대해 암호화 해시함수를 이용하여 얻어진 해시값을 h(A)라고 하자. h(A) 값이 존재하는 것은 이전 A데이터가 있는 것이 논리적으로 옳다고 본다. 또한, B = h(A)로 h(B)를 계산하면 h(B)가 존재하기 전에 h(A)가 존재하고 있었다고 볼 수 있다. 이처럼 동일한 데이터에 대해 재귀적으로 암호화 해시함수를 적용하는 기술이 해시체인이다. 이 해시체인은 일회성 비밀번호 인증 시스템 구현에서 주로 사용된다.


#### 확장된 해시체인
![ExHashserver](./image/extended_hash_timeserver.png)

블록체인은 위의 확장된 해시체인을 사용하여 모든 데이터의 존재증명과 전후 관계를 증명할 수 있다. 실무적인 P2P 시스템에서 사용하기 위해서는 몇가지 이슈를 해결해야 한다.
1. 여러 개의 노드가 참여하는 P2P 네트워크에서 모든 노드가 항상 최신 타임스탬프를 볼 수 있는가?
2. 노드가 과거 데이터를 변조한 경우, 변주 탐지 및 변조 데이터를 거부할 수 있는가?
블록체인에서는 첫 번째 이슈를 해결하기 위해 모든 데이터를 항상 모든 노드에서 공유하지 않고 여러 데이터를 정리한 블록단위로 공유한다. 이 블록을 만드는데 사용되는 기술이 <b><a href="http://brownbears.tistory.com/372">머클트리(Merkle tree 또는 Hash tree)</a></b>이다. 또한, 이 머클트리를 사용하여 두 번째 이슈를 해결할 수 있다.

